/**
 * T-2.1 & T-2.2: Effect Schema Generator
 *
 * Generates Effect Schema class definitions from CodegenSupertag.
 */

import type { CodegenSupertag, CodegenField, CodegenOptions } from "./types";

/**
 * Generate JSDoc comment block.
 */
function generateJsDoc(lines: string[]): string {
  if (lines.length === 0) return "";
  if (lines.length === 1) {
    return `  /** ${lines[0]} */\n`;
  }
  return `  /**\n${lines.map((l) => `   * ${l}`).join("\n")}\n   */\n`;
}

/**
 * Generate a single field definition.
 */
function generateField(field: CodegenField): string {
  let result = "";

  // Add JSDoc comment if present
  if (field.comment) {
    result += generateJsDoc([field.comment]);
  }

  // Add field definition
  result += `  ${field.propertyName}: ${field.effectSchema},\n`;

  return result;
}

/**
 * Generate metadata comment block for a class.
 */
function generateMetadataComment(tag: CodegenSupertag): string {
  return `/**
 * Generated from Tana supertag: ${tag.name}
 * Supertag ID: ${tag.metadata.tagId}
 * Last synced: ${tag.metadata.syncedAt}
 */\n`;
}

/**
 * Generate a single Effect Schema class.
 *
 * @param tag - Supertag to generate class for
 * @param options - Generation options
 * @returns TypeScript class definition
 */
export function generateEffectClass(
  tag: CodegenSupertag,
  options: CodegenOptions
): string {
  const lines: string[] = [];
  const hasParent = !!tag.parentClassName;

  // Add metadata comment if enabled
  if (options.includeMetadata) {
    lines.push(generateMetadataComment(tag));
  }

  // Start class definition - use extend() for child classes
  if (hasParent) {
    // Child class extends parent using .extend()
    lines.push(
      `export class ${tag.className} extends ${tag.parentClassName}.extend<${tag.className}>("${tag.className}")({`
    );
  } else {
    // Root class uses Schema.Class
    lines.push(
      `export class ${tag.className} extends Schema.Class<${tag.className}>("${tag.className}")({`
    );
  }

  // Only add id field for root classes (children inherit from parent)
  if (!hasParent) {
    lines.push(generateJsDoc(["Tana node ID"]));
    lines.push(`  id: Schema.String,\n`);
  }

  // Add user-defined fields
  for (const field of tag.fields) {
    lines.push(generateField(field));
  }

  // Close class
  lines.push("}) {}");

  return lines.join("");
}

/**
 * Options for generating Effect Schema files.
 */
export interface GenerateFileOptions {
  /** Import statements for parent classes in split mode */
  parentImports?: { className: string; from: string }[];
}

/**
 * Generate a complete Effect Schema file with imports and multiple classes.
 *
 * @param tags - Supertags to include in the file
 * @param options - Generation options
 * @param fileOptions - Additional file generation options
 * @returns Complete TypeScript file content
 */
export function generateEffectFile(
  tags: CodegenSupertag[],
  options: CodegenOptions,
  fileOptions?: GenerateFileOptions
): string {
  const lines: string[] = [];

  // File header
  lines.push("/**");
  lines.push(" * Generated by supertag-cli codegen");
  lines.push(" * DO NOT EDIT - This file is auto-generated");
  lines.push(` * Generated at: ${new Date().toISOString()}`);
  lines.push(" */");
  lines.push("");

  // Import statement
  lines.push('import { Schema } from "effect";');

  // Add parent class imports for split mode
  if (fileOptions?.parentImports && fileOptions.parentImports.length > 0) {
    for (const imp of fileOptions.parentImports) {
      lines.push(`import { ${imp.className} } from "${imp.from}";`);
    }
  }

  lines.push("");

  // Generate each class
  for (let i = 0; i < tags.length; i++) {
    const tag = tags[i];
    lines.push(generateEffectClass(tag, options));

    // Add blank line between classes (but not after the last one)
    if (i < tags.length - 1) {
      lines.push("");
    }
  }

  return lines.join("\n");
}
